<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=ISO-8859-1">
  <title>OpenSteer Preliminary Documentation</title>
  <style type="text/css">
  .graybox    { vertical-align: top;
                padding: 2px 8px 2px 8px;
                color: black;
                background-color: #e0e0e0; }
  .boxVM      { vertical-align: middle;
                padding: 0 0 0 0;
                color: black;
                background-color: white; }
  .boxVMxxx   { vertical-align: middle;
                padding: 0 0 0 0;
                color: black;
                background-color: yellow; }
  .boxVT      { vertical-align: top;
                padding: 0 0 0 0;
                color: black;
                background-color: white;}
  .sourcecode { font-family: monospace; }
  .nowrap     { white-space: nowrap; }
  body        { color: black;
                background-color: white; }
  </style><!-- I should define a span-level style for code (and one for pathnames,
       "vocabulary" words (like "scare quotes") -->
</head>
<body>

<table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tbody>
    <tr>
      <td class="boxVT" align="left"> 
      <b><big><big><big><big>OpenSteer</big></big><br>
      Documentation </big></big></b>
      <br>
      <br>
      <br>
      <!-- CHANGE DATE AT BOTTOM OF FILE TOO -->
      <small>October 7, 2003<br>
      <small>Version 0.8</small></small>
      <br>
      <br>
      <br>
      <br>
      <br>
      <br>
      by <br>
      <a href="http://www.red3d.com/cwr/">Craig Reynolds</a> <br>
      <a href="http://www.research.scea.com/">Research and Development</a>
      <br>
      <a href="http://www.scea.com/">Sony Computer Entertainment America</a>
      </td>
      <td class="boxVM" align="right"> <a href="index.html"><img
 src="images/beta_250a.gif" width="250" height="250" border="0"
 alt="OpenSteer Logo"></a> </td>
    </tr>
  </tbody>
</table>


<br>
<br>
<br>
<br>
<br>
<table border="0" cellspacing="0" cellpadding="0" width="100%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox"> <big><big> <b><br>
      <a name="TableofContents"></a>Table of Contents </b></big> </big><br>
      <a href="#Introduction">Introduction</a> <br>
      <a href="#WetPaint">Wet Paint</a> <br>
      <a href="#UsingSteerTest">Using SteerTest</a> <br>
      <a href="#SamplePlugIns">Sample PlugIns</a> <br>
      <a href="#WritingPlugIns">Writing PlugIns</a> <br>
      <a href="#SteeringLibrary">Steering Library</a> <br>
      <a href="#Integrating">Integrating with Your Code</a> <br>
      <a href="#InstallingOpenSteer">Installing OpenSteer</a> <br>
      <a href="#KnownBugs">Known Bugs and Missing Features</a> <br>
      <a href="#RelatedLinks">Related Links</a> <br>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
<big>
<big><b><br>
<a name="Introduction"></a>
Introduction
</b></big></big>
<p><b>OpenSteer</b> is an open source library of components to help
build <a href="http://www.red3d.com/cwr/steer/">steering behaviors</a>
for autonomous characters in games and other kinds of multi-agent
simulations. These agents may represent characters (humans, animals,
alien creatures), vehicles (cars, planes, spaceships) or other kinds
of mobile agents. OpenSteer was originally developed on Linux and
subsequently ported to Windows and Mac OS X.</p>
<p>OpenSteer provides a toolkit of steering behaviors, defined in
terms of an abstract mobile agent called a <i>vehicle. </i>Sample code
is provided, including a simple vehicle implementation and examples of
combining simple steering behaviors to produce more complex
behavior. In order to allow flexible integration with existing game
engines OpenSteer can add its functionality by either layering or
inheritance. <small><a href="#Integrating">[see "Integrating with Your
Code" below]</a></small> Note that Opensteer is intended for use by
programmers. It does not plug into interactive production tools, nor
does it support behavior authoring by non-programmers.</p>
<p>In addition to the library, OpenSteer provides an
interactive application called <b>SteerTest</b> which initially
demonstrates several steering behaviors. SteerTest can also help you
create novel steering behaviors, providing facilities to visualize,
annotate and debug your code. SteerTest is written in C++ and uses
OpenGL
graphics. All OpenGL calls are segregated in one module, in case you
need to substitute another graphics API.
</p>
<p>SteerTest is based on a <i>plug-in</i> architecture: an empty
framework into which plug-ins can be added incrementally. SteerTest
comes with several sample plug-ins.
<small><a href="#SamplePlugIns">[see "Sample PlugIns"
below]</a></small> You can easily create your own plug-ins by starting
from these examples. A SteerTest plug-in specifies several generic
actions required by the SteerTest framework: open, close, reset, run
one simulation step, display one frame, and so on. The plug-in defines
vehicle classes and manages them in simulation. It defines scene
geometry in terms of obstacles, pathways and so on. Plug-ins control
the camera and handle Function Keys.</p>
<p>SteerTest's plug-in framework allows a game AI programmer to
quickly prototype behaviors during game design, and to develop
behaviors before the main game engine is finished. In OpenSteer 0.8,
SteerTest allows the user to interactively control simulation time
(stop, start, single step), select the vehicle/character/agent of
interest, and adjust the
view and tracking behavior of the camera.</p>
<p>OpenSteer is distributed as open source software in accordance with
the <a href="http://www.opensource.org/licenses/mit-license.php">MIT
License</a>.</p>
<big>
<big><b><br>
<a name="WetPaint"></a>
Wet Paint!
</b></big></big>
<p>Warning: OpenSteer 0.8 is still under active development. It is
not mature or stable. Its current design is subject to change and
reorganization, although every attempt will be made to avoid
gratuitous changes. We welcome your interest in OpenSteer and
encourage experimentation. However please <a href="contact.html">contact
us</a> before planning to integrate
OpenSteer into any large project.</p>
<p>Note also that the term <i>plug-in</i> is currently misused here.
Normally it implies that a new module can be added to an application
at <b>run</b> time. Whereas in OpenSteer 0.8 the "plugging-in" must
happen at application <b>build</b> (link) time. One would hope this
was fixed in a future release (he said, hoping to avoid specific
promises of future enhancements).</p>
<big>
<big><b><br>
<a name="UsingSteerTest"></a>
Using SteerTest
</b></big></big>
<p>After installation <small><a href="#InstallingOpenSteer">[see
"Installing OpenSteer" below]</a></small> launch the SteerTest
application. <small>(On Linux, Mac or Windows you can do this by
double clicking on a desktop icon. If you have downloaded the
OpenSteer source code and compiled it yourself, you can also launch the
application from your IDE build tools. If you use the supplied
Makefile for Linux, you can execute the <span
 style="font-weight: bold;">make run</span> command.)</small> When you
first use SteerTest, this <a href="stref.html">quick
reference guide</a> may be helpful. The application will open a
single window labeled "SteerTest 0.8". You should see a diagrammatic 3d
view of the default PlugIn. Typically you will see moving vehicles,
annotation graphics and textual overlays, as shown in <small><a
 href="#Figure1">[Figure 1]</a></small>.</p>
<a name="Figure1"></a>
<div align="center"><img src="images/typical_SteerTest.png" width="673"
 height="558" alt="typical SteerTest window"><br>
<br>
Figure 1: typical SteerTest window
<br>
</div>
<p>Eventually SteerTest may have a menu-based graphical user
interface. For now it supports limited mouse-based interaction
(camera view adjustment, vehicle selection) and recognizes several
single key commands:</p>
<table border="0" cellspacing="3" cellpadding="0" width="90%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox" width="25%">Tab</td>
      <td class="graybox">select next PlugIn</td>
    </tr>
    <tr>
      <td class="graybox">r</td>
      <td class="graybox">restart current PlugIn</td>
    </tr>
    <tr>
      <td class="graybox">s</td>
      <td class="graybox">select next vehicle/agent/character&nbsp; (or
mouse-click to select)</td>
    </tr>
    <tr>
      <td class="graybox">c</td>
      <td class="graybox">select next camera aiming mode</td>
    </tr>
    <tr>
      <td class="graybox">f</td>
      <td class="graybox">select next preset frame rate&nbsp;
(as-fast-as-possible, 24fps, 60fps)</td>
    </tr>
    <tr>
      <td class="graybox">a</td>
      <td class="graybox">toggle annotation on/off</td>
    </tr>
    <tr>
      <td class="graybox">Space</td>
      <td class="graybox">toggle between Run and Pause</td>
    </tr>
    <tr>
      <td class="graybox">-&gt; &nbsp; (right arrow)</td>
      <td class="graybox">step forward one frame</td>
    </tr>
    <tr>
      <td class="graybox">?</td>
      <td class="graybox">print "mini help" on console&nbsp; (or see
the <a href="stref.html">quick reference guide</a>)</td>
    </tr>
    <tr>
      <td class="graybox">Esc</td>
      <td class="graybox">exit SteerTest</td>
    </tr>
  </tbody>
</table>
<p>In addition a PlugIn can provide handlers for the Function
Keys (labeled F1 through F12 on most keyboards). Typing a <span
 style="font-weight: bold;">?</span> should list which ones are handled
by the current PlugIn.</p>
<p>SteerTest keeps track of a single <i>selected</i> agent which the
camera follows. In some demos additional annotation is provided for
the selected agent. The user can change selection with the mouse.
Pointing the mouse near an agent will cause it to highlight (for
example, in the provided 2d demos, a gray disk is drawn under it).
Clicking the (left) mouse button selects the highlighted agent.
SteerTest's camera (<i>point of view</i>) adjusts itself automatically
to keep the selected vehicle in view. Several different camera aiming
modes are provided:</p>
<table border="0" cellspacing="3" cellpadding="0" width="90%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox" width="25%">static</td>
      <td class="graybox">fixed camera</td>
    </tr>
    <tr>
      <td class="graybox">fixed&nbsp;distance&nbsp;offset</td>
      <td class="graybox">camera remains a fixed distance from selected
vehicle </td>
    </tr>
    <tr>
      <td class="graybox">fixed local offset</td>
      <td class="graybox">camera remains fixed in selected vehicle's
local space </td>
    </tr>
    <tr>
      <td class="graybox">straight down</td>
      <td class="graybox">camera looks at selected vehicle from
directly above </td>
    </tr>
    <tr>
      <td class="graybox">offset POV</td>
      <td class="graybox">camera looks in selected vehicle's forward
direction, from a given
offset in the vehicle's local space </td>
    </tr>
  </tbody>
</table>
<p>You can adjust the camera's view with the mouse (or whatever input
device you use). SteerTest lets you adjust the camera's <i>position
</i>relative to its <i>aimpoint. </i>The aimpoint is defined by
camera
aiming mode and is normally the (predicted future position of the)
selected vehicle. To adjust the camera: hold down the keyboard's
<i>control </i>(Ctrl) key while dragging the mouse with its left
button held down. 2D mouse motion is mapped into the camera's space,
rotating the camera's position around its aimpoint. This allows the
camera to move on the surface of a sphere centered at the aimpoint.
The radius of this sphere--the "viewing distance"--can be adjusted by
dragging the mouse with the middle button held down (vertical mouse
motion maps to distance). If you use a one- or two-button mouse
(hence no middle button) you can adjust the radius by holding down
both the Ctrl and Alt ("control-meta-") keys while dragging the mouse
with its left button held down. Note that adjustments in "offset POV"
camera aiming mode actually translate rather than rotate the camera
position relative to the selected vehicle.</p>
<p>To preserve a stable view, SteerTest's camera will smoothly
interpolate over changes due to: motion of the selected vehicle,
mouse-based camera adjustment, or switching camera aiming modes.</p>
<p>SteerTest's clock provides two time streams: <i>real time </i>and
<i>simulation time. </i>The redraw cycle and camera update are based
on passage of real time. Simulation time normally follows real time
but can also be <i>paused, </i>freezing simulation of vehicle motion.
Pausing the simulation often helps to allow examining annotation in
detail, or to interactively reposition the camera. (In the current
implementation: when simulation time is paused, simulation updates
continue to happen each frame, but the <i>elapsed time </i>("dt") is
given as zero.) The clock can be set to run in either a variable frame
rate
"as fast as possible" mode or to run at a given fixed frame rate. In
the latter, the system will wait after a simulate-redraw for the start
of a new frame boundary. If the update takes longer than a frame time
it waits for the second frame boundary (aka "frame out" or "double
framing"). You can control this behavior with SteerTest's
<b>&nbsp;f&nbsp;</b> keyboard command (to cycle among frame rate
presets) or from your PlugIn code by setting<span class="sourcecode">
SteerTest::clock.targetFPS </span>(an int) to the desired frame rate,
or 0 for variable frame rate. For more detail, see <b>Clock.h</b></p>
<p>SteerTest aims to support a developer's work by providing tools and
utilities that while helpful, might not be critical enough to justify
writing them during a production schedule. This includes various API
for drawing annotation using elements such as lines, vectors, boxes,
circles, disks, spheres and text attached to the screen or positions
in 3d space. A facility is provided for drawing <i>streamers/trails
</i>which display a vehicle's recent motion then fade away. There are
utilities for drawing a ground plane and highlighting vehicles in
various ways. See <b>Annotation.h</b> and <b>SteerTest.h</b> for
details. You can turn annotation on and off with SteerTest's <b>&nbsp;a&nbsp;</b>
command.</p>
<p>
<big><big><b><br>
<a name="SamplePlugIns"></a>
Sample PlugIns
</b></big></big></p>
SteerTest is distributed with several PlugIns intended to serve both
as demonstrations of steering behaviors, and as sample code: jumping
off places for you to begin developing your own steering behaviors.
The current list of sample PlugIns are:
<p><b>Capture the Flag:</b> a single (bluish) attacker attempts to
reach a central goal while four (reddish) defenders try to intercept
("tag") the attacker before it gets to the goal. The playing field is
optionally littered with obstacles. This benchmark was proposed by
Marcin Chady of the Working Group on Steering of the IGDA's AI
Interface Standards Committee. The obstacles are spheres, depicted by
their equator. Press F1 to add an obstacle (up to 100 of them), F2 to
remove one. The "game" ends when the attacker reaches the goal or a
defender tags the attacker. The demo automatically restarts a few
seconds later. The attacker combines three basic steering behaviors:
<i>goal seeking,</i> <i>evasion</i> and <i>obstacle avoidance</i>.
The defenders combine <i>pursuit</i> and <i>obstacle avoidance.</i> A
key to "non-stupid" behavior by the attacker was to notice when there
is a defender-free "corridor" between it and the goal. When found,
this corridor is depicted by a green outline. In this case the
attacker uses pure <i>seek</i> and stops evading nearby defenders.
The pursuit behavior of the defenders needed to specialized so that
they "knew" not to predict the motion of the attacker past its goal.
The defenders do not otherwise think about global strategy, for
example they don't try to place themselves between the attacker and
the goal. Currently defenders ignore each other, they probably should
separate or avoid collisions with each other, ideally they would
coordinate their pursuit. The attacker is easily confused when
several defenders converge from different directions. Obstacles are
always avoided by going toward the nearer edge, as discussed in the
Steering Working Group's forum, this is frequently the "wrong"
direction when considering the agent's other goals. I want to revisit
this later.</p>
<p><b>Pedestrians:</b> 100 agents follow a path (the red line) and try
not to collide with each other or two large spherical obstacles.
Press F1 to add a Pedestrian and F2 to remove one. This multiagent
simulation uses a spatial database to accelerate proximity queries, F3
cycles among types of proximity databases (two exist in OpenSteer
0.8). F4 toggles between two versions of path following: <span
 style="font-style: italic;">stay on the
path </span>and <span style="font-style: italic;">directed path
following.</span> The latter means to stay on
the path while moving along it in a given direction. A Pedestrian's
direction is
reversed when reaches the end of the path. Press F5 to toggle a
Pedestrian's <span style="font-style: italic;">wander
</span>component on and off.</p>
<p><b>Boids:</b> 200 simulated flocking <a
 href="http://www.red3d.com/cwr/boids/">bird like objects</a>. The
boids model is a simple combination of <i>separation, alignment
</i>and <i>cohesion </i>steering behaviors. Press F1 to add a Boid
and F2 to remove one. This multiagent simulation uses a spatial
database to accelerate proximity queries, F3
cycles among types of proximity databases (two exist in OpenSteer
0.8). The flock flies within a sphere, F4 toggles between two boundary
conditions. One is "steer back when outside" -- when a boid
travels
outside the sphere it begins to <i>seek</i>
towards the center. The other is "wrap around (teleport)" --
boids that fly out of the sphere are instantly repositioned to the
opposite side of the sphere.<br>
</p>
<p><span style="font-weight: bold;">Soccer:</span> this simulation of a
simple soccer game was contributed by Michael Holm of <a
 href="http://www2.ioi.dk/">IO Interactive</a> on July 9, 2003.
It consists of a blue and red team of 8 Players each, a green Ball and
an <span style="font-style: italic;">axis aligned bounding box</span>
class (AABBox) used to represent the field and the two goals. As
play proceeds the PlugIn keeps score. The ball is derived from
SimpleVehicle but its vehicle-like motion is replaced by bounce
physics. Michael invites others to contribute improved Player
designs. <br>
</p>
<p><b>Multiple Pursuit:</b> a "test fixture" for the <i>pursue</i>
behavior. 30 pursuers chase one wandering quarry. The colored lines
indicate the predicted future position of the quarry being used as a
<i>seek</i> target by each pursuer. The colors indicate which of nine
prediction cases is active. When a pursuer reaches the quarry it is
"teleported" away to a random position.</p>
<p><b>Low Speed Turn:</b> a "test fixture" for evaluating the response
of a vehicle to backward-pointing steering force while moving at low
speed.</p>
<p><b>One Turning Away:</b> this was the first one, now it serves as a
minimal example of a PlugIn.</p>
<p>
<big><big><b><br>
<a name="WritingPlugIns"></a>
Writing PlugIns
</b></big></big></p>
<p><i>Note: this section is preliminary, incomplete and subject
to change.</i></p>
<p>Developing interesting, lifelike steering behaviors is an unique
type of programming. It mixes the mathematical and algorithmic rigor
of computer programming with a more artistic, aesthetic-based phase of
parameter tweaking. OpenSteer is intended to allow you to focus on
developing steering behaviors without having to worry about all of the
required framework. This is supported through SteerTest's PlugIn
mechanism. When you write a PlugIn, you need to provide only the code
that is specific to your own steering behaviors and vehicles.</p>
<p>Currently the best source of detailed information on the PlugIn
interface is in the C++ header file <b>PlugIn.h</b>. See particularly
the commented-out meta-example called<span class="sourcecode">
FooPlugIn. </span>That header file defines two classes:<span
 class="sourcecode"> AbstractPlugIn </span>(a pure virtual interface
class) and<span class="sourcecode"> PlugIn </span>which provides the
base implementation. To create a new SteerTest PlugIn, you will
define a new class which inherits the base implementation from<span
 class="sourcecode"> PlugIn. </span>It provides some default methods
(see
<b>PlugIn.h</b> for details) which you can overload to customize,
particularly<span class="sourcecode"> reset</span>. You must implement
six methods on your new class to fulfill the<span class="sourcecode">
AbstractPlugIn </span>protocol:</p>
<table border="0" cellspacing="3" cellpadding="0" width="90%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox" width="25%"><span class="sourcecode">name</span></td>
      <td class="graybox">returns a character string name</td>
    </tr>
    <tr>
      <td class="graybox"><span class="sourcecode">open</span></td>
      <td class="graybox">allocate and initialize vehicles</td>
    </tr>
    <tr>
      <td class="graybox"><span class="sourcecode">close</span></td>
      <td class="graybox">deallocate</td>
    </tr>
    <tr>
      <td class="graybox"><span class="sourcecode">update</span></td>
      <td class="graybox">perform one stimulation step</td>
    </tr>
    <tr>
      <td class="graybox"><span class="sourcecode">redraw</span></td>
      <td class="graybox">do all graphics for one frame</td>
    </tr>
    <tr>
      <td class="graybox"><span class="sourcecode">allVehicles</span></td>
      <td class="graybox">return a group of all this PlugIn's vehicles</td>
    </tr>
  </tbody>
</table>
<p>For a minimal working PlugIn see "One Turning Away"
(<b>opensteer/plugins/OneTurning.cpp</b>) which defines a single
vehicle with trivial behavior. LowSpeedTurn also has trivial behavior
and features multiple vehicles, Boids has many vehicles,
MultiplePursuit has two kinds of vehicles, Pedestrian and
CaptureTheFlag are more complicated samples.</p>
<p>Probably the easiest way to get started on your own PlugIn is to
pick one of the samples that seems most closely related, make a
renamed copy of it, build OpenSteer to verify that the new PlugIn
appears in SteerTest and has its old behavior, then make incremental
changes to the working PlugIn. (Note: <b>in OpenSteer 0.8: </b>you
should leave your new PlugIn's source file in the same directory as
the provided sample PlugIns (<b>opensteer/plugins/</b>). That way it
will be automatically compiled and linked when OpenSteer is built,
without requiring any changes to the Makefile.)</p>
<p>The samples in <b>opensteer/plugins/</b> each define at least one
new vehicle class and one new PlugIn class. A key requirement is that
a single instance of the new PlugIn class be statically allocated, as
in:</p>
<blockquote> <span class="sourcecode">// define a new Vehicle<br>
class OneTurning : public SimpleVehicle {...}<br>
  <br>
// define a new PlugIn<br>
class OneTurningPlugIn : public PlugIn {...}<br>
  <br>
// instantiate the PlugIn<br>
  <b>OneTurningPlugIn gOneTurningPlugIn;</b> </span></blockquote>
<p>The name of that global (<span class="sourcecode">gOneTurningPlugIn</span>)
is irrelevant, what
matters is that a single instance of the new PlugIn class (<span
 class="sourcecode">OneTurningPlugIn</span>) is allocated for the
lifetime of the SteerTest application. The actual "plugging in" is
handled by the constructor(/destructor) of the<span class="sourcecode">
PlugIn</span> base class. A class which is intended to be
instantiated exactly once is sometimes called a <i>singleton</i>.
PlugIns expect to be instantiated exactly once but do not enforce or
detect violations of that policy. Because PlugIns register
themselves, the samples are defined in <b>.cpp</b> files and there is
no need for <b>.h</b> files. You may wish to organize your PlugIn
differently, perhaps with a <b>.h</b> file or perhaps including one
for a class of vehicle defined elsewhere.</p>
<p>Normally your PlugIn will define one or more classes of Vehicle.
OpenSteer tries to provide a lot of flexibility in how this can be
done. On the other hand, if you are just trying to get your first
experiment running under SteerTest, you probably want what Devo called
"freedom <i>from </i>choice." The easiest approach, and what all the
provided samples do, is to define a new vehicle class as a
specialization of<span class="sourcecode"> SimpleVehicle. </span>In
general, all that is required to make use of the OpenSteer steering
library is to support the<span class="sourcecode">
AbstractVehicle</span> protocol in whatever manner you see fit.</p>
<p>SteerTest and the provided PlugIns make use of two types defined
in<span class="sourcecode"> AbstractVehicle: AbstractVehicle::group
</span>and<span class="sourcecode"> AbstractVehicle::iterator</span>.
These are<span class="sourcecode"> typedef</span>ed to the names<span
 class="sourcecode"> AVGroup </span>and<span class="sourcecode">
AVIterator. AVGroup</span> is used whenever a group of<span
 class="sourcecode"> AbstractVehicle</span>s need to be remembered or
passed as a function argument.<span class="sourcecode">
AVIterator </span>is used to iterate over the contents of an<span
 class="sourcecode"> AVGroup. </span>These types are based on the C++
STL
(Standard Template Library) parameterized types<span class="sourcecode">
vector </span>and<span class="sourcecode"> const_iterator. AVGroup
</span>and<span class="sourcecode"> AVIterator </span>are used inside
the OpenSteer library, but if you wish to avoid using STL it should be
easy to replace them with your own implementation of collections and
iteration.</p>
<p>Random notes for PlugIn writers:
</p>
<ul>
  <li>
    <p>Time values are currently passed as float values, measured in
seconds. Perhaps there should be a more specific typedef for time.</p>
  </li>
  <li>
    <p><span class="sourcecode">Vec3 </span>is the type used
throughout
OpenSteer to represent geometric vectors in 3d Cartesian space.
Colors are currently represented as <span class="sourcecode">Vec3</span>s.
Perhaps there should be a
more
specific typedef for color.</p>
  </li>
  <li>
    <p>One way to help debug or analyze your steering behaviors is to
pick one vehicle and provide additional information about it, using
graphical annotation or printed output. A convenient choice is
SteerTest's <span style="font-style: italic;">selected vehicle: </span>the
one the camera normally follows and which can be changed with a mouse
click (or the SteerTest <b>&nbsp;s&nbsp;</b> command). To trigger code
specifically for the selected vehicle, use something like this in your
vehicle's update method:&nbsp;&nbsp; <span class="sourcecode">if&nbsp;(this&nbsp;==&nbsp;SteerTest::selectedVehicle)&nbsp;{...}</span>
    </p>
  </li>
</ul>
<p>
<big><big><b><br>
<a name="SteeringLibrary"></a>
Steering Library
</b></big></big></p>
<p><i>Note: this section is preliminary and subject to change. The
documentation could conceivably be out of sync with the library itself.
For the Real Truth always consult the source code.</i></p>
<p>In current organization of OpenSteer, its main library of steering
behaviors is contained in the class SteerLibraryMixin (defined in
<b>SteerLibrary.h</b>). A mixin is a class with templated superclass
-- it is used to add a set of methods to a given base class.
<small><a href="#Integrating">[see "Integrating with Your Code"
below]</a></small> In this case, SteerLibraryMixin adds steering
functionality to a class which supports the AbstractVehicle interface.
For example, SimpleVehicle combines SteerLibraryMixin and several
other utilities with AbstractVehicle. As a result, SimpleVehicle has
all of the methods defined in SteerLibraryMixin, which are listed
below.</p>
<p>Note that several of the steering behaviors will return a zero
vector value (0, 0, 0) to indicate "no steering is required at this
time" typically because a goal is already met. The caller can detect
these cases by testing to see if
the returned steering value is equal to zero:&nbsp;&nbsp;
<span class="sourcecode">if&nbsp;(steering&nbsp;==&nbsp;Vec3::zero)&nbsp;...</span></p>
<b>Wander behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForWander (float dt);<br></pre>
  <p>Returns a steering force for wandering behavior. The steering
value is purely tangential (has no Forward component). The time step
value allows wander rate to be consistent when frame times vary.</p>
</blockquote>
<b>Seek behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForSeek (const Vec3&amp; target);<br></pre>
  <p>Returns a steering force to seek the given target location. Causes
a vehicle to turn toward the target and move to it. If this behavior
is used alone and unconditionally, it will cause the vehicle to pass
through the target then turn around for another pass.</p>
</blockquote>
<b>Flee behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForFlee (const Vec3&amp; target);<br></pre>
  <p>Returns a steering force to flee from the given target location.
Causes a vehicle to turn away from the target and move away from it
it.</p>
</blockquote>
<b>Path Following behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerToFollowPath (const int direction,<br>                        const float predictionTime,<br>                        Pathway&amp; path)<br><br>Vec3 steerToStayOnPath (const float predictionTime, Pathway&amp; path)<br></pre>
  <p>Returns a steering force to follow a given path. <span
 class="sourcecode">steerToStayOnPath</span> just tries to keep the
vehicle on the path. <span class="sourcecode">steerToFollowPath</span>
provides <span style="font-style: italic;">directed path following </span>where
the vehicle both stays on the path and heads in a given direction along
the path, as indicated by the <span class="sourcecode">direction</span>
argument which should be either +1 or -1. The path
defines a <i>tube </i>in terms of a <i>spine </i>and a <i>radius </i>,
the goal is to keep a vehicle headed toward a point inside that tube.
(OpenSteer 0.8 provides only one kind of Path with a polyline spine: a
series of lined line segments, see <span style="font-weight: bold;">Pathway.h</span>)
Steering is determined based on a prediction of the vehicle's
position<span class="sourcecode"> predictionTime </span>seconds into
the
future. If that predicted position is inside the pathway (and in the
case of directed path following, is headed in the correct direction)
this
function returns a zero vector value. Otherwise it steers toward
a point on the path.<br>
  </p>
</blockquote>
<b>Obstacle Avoidance behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerToAvoidObstacle (const float minTimeToCollision,
                           const Obstacle&amp; obstacle);

Vec3 steerToAvoidObstacles (const float minTimeToCollision,
                            const ObstacleGroup&amp; obstacles)</pre>
  <p>Returns a steering force to avoid given obstacles. The obstacles
can be specified as either a single Obstacle or as a
ObstacleGroup (an STL Vector of Obstacle pointers). The purely
lateral steering force will turn our vehicle towards a silhouette edge
of the obstacle. Avoidance is required when (1) the obstacle
intersects the vehicle's current path, and (2) it is in front of the
vehicle, and (3) is within<span class="sourcecode"> minTimeToCollision </span>seconds
of travel at the vehicle's current velocity. If multiple Obstacles were
specified, and multiple potential collisions exist, the nearest (most
urgent) one is chosen. When no
avoidance is required this function returns a zero vector value.
Note that the older <span class="sourcecode">steerToAvoidObstacle</span>
calling sequence may be changed or removed in the future.<br>
  </p>
</blockquote>
<b>Unaligned Collision Avoidance behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerToAvoidNeighbors (const float minTimeToCollision,<br>                            const AVGroup&amp; others);<br></pre>
  <p>Returns a steering force to avoid colliding with other nearby
vehicles moving in unconstrained directions. Determine which (if any)
other other vehicle we would collide with first, then steers to avoid
the site of that potential collision. (The current version only
steers laterally, it does not speed up or slow down, as described in
the <a href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">GDC
1999 paper</a>.) Returns a steering force vector of zero length if
there is no impending collision.</p>
</blockquote>
<b>Separation behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForSeparation (const float maxDistance,<br>                         const float cosMaxAngle,<br>                         const AVGroup&amp; flock);<br></pre>
  <p>Returns a steering force to move us away from nearby boids.</p>
</blockquote>
<b>Alignment behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForAlignment (const float maxDistance,<br>                        const float cosMaxAngle,<br>                        const AVGroup&amp; flock);<br></pre>
  <p>Returns a steering force to align us with nearby boids.</p>
</blockquote>
<b>Cohesion behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForCohesion (const float maxDistance,<br>                       const float cosMaxAngle,<br>                       const AVGroup&amp; flock);<br></pre>
  <p>Returns a steering force to move us towards the "center of mass"
of
nearby boids.</p>
</blockquote>
<b>Pursuit behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForPursuit (const AbstractVehicle&amp; quarry);<br><br>Vec3 steerForPursuit (const AbstractVehicle&amp; quarry,<br>                      const float maxPredictionTime);<br></pre>
  <p>Returns a steering force to pursue another moving vehicle. Heads
towards the predicted point of interception. An alternate version is
provided to specify a ceiling on the prediction interval: aim for
where the quarry will be in (say) 5 seconds, or the point of
interception, whichever happens sooner.</p>
</blockquote>
<b>Evasion behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForEvasion (const AbstractVehicle&amp; menace,<br>                      const float maxPredictionTime);<br></pre>
  <p>Returns a steering force to evade another moving vehicle. Heads
away from the predicted point of interception.</p>
</blockquote>
<b>Speed Maintenance behavior</b>
<br>
<blockquote>
  <pre>Vec3 steerForTargetSpeed (const float targetSpeed);<br></pre>
  <p>Returns a steering force to maintain a given target speed. The
value will be along the vehicle's forward/backward axis and its length
will be clipped to the vehicle's maxForce parameter.</p>
</blockquote>
<p>
<big><big><b><br>
<a name="Integrating"></a>
Integrating with Your Code
</b></big></big></p>
<p><i>Note: this section is so preliminary that it is really just a
placeholder...</i></p>
<p>This section will eventually talk about the structure of
OpenSteer's classes, and how they are designed to provide you with
flexibility as you integrate OpenSteer with your existing code. It
will mention that if you were writing new code, you could always base
your classes on OpenSteer's. More typically you will already have an
existing code base, a game engine or a procedural animation system,
into which you want to integrate some of OpenSteer's facilities.</p>
<p>OpenSteer's classes have been designed to allow you freedom to
either inherit its functionality, or to layer its functionality on top
of your existing classes. The latter approach is supported by the
concept of <a
 href="http://citeseer.nj.nec.com/smaragdakis00mixinbased.html">
mixin classes</a> (essentially a class with templated superclass)
which allows its functionality to be "mixed in with" (or "layered on
top of") your existing classes. A similar effect can be obtained by
multiple inheritance of your preexisting base classes and OpenSteer's
classes, but most C++ programmers prefer to avoid multiple
inheritance. Many of OpenSteer's classes are defined in three parts:
an abstract protocol (aka interface or pure virtual class:
"AbstractLocalSpace"), an implementation expressed as a mixin
("LocalSpaceMixin") and an instantiable class made by layering the
mixin on top of the abstract protocol ("LocalSpace"). For more detail
see <b>LocalSpace.h</b> and the discussion at the top of
<b>SimpleVehicle.h</b></p>
<p>Finally OpenSteer anticipates that it may be used in class
hierarchies based on either the IS-A or the HAS-A architecture. That
is, you might want an agent in your game to be structured so that it
IS-A OpenSteer Vehicle or you may want to structure it so that it HAS-A
Vehicle as a component part.</p>
<p>
<big><big><b><br>
<a name="InstallingOpenSteer"></a>
Installing OpenSteer
</b></big></big></p>
<p><i>Note: this section is preliminary and subject to change.
OpenSteer 0.8 uses two external libraries: OpenGL and GLUT, you
may need to install them before you can build OpenSteer.</i></p>
<p>You can download software at
<a href="http://sourceforge.net/project/showfiles.php?group_id=77546">OpenSteer's
file release page at SourceForge</a>. There you will find both the
source code and precompiled SteerTest applications. The source code is
in a zip archive called
<b>OpenSteer_0_8_source.zip</b>. The SteerTest application is available
as precompiled binary executables for Linux, Mac OS X, and Windows. <br>
</p>
<p>OpenSteer 0.8 includes a Makefile to
build the system under Linux and related systems. We hope to provide
support for IDEs (Integrated Development
Environments, such as Xcode and Visual C++) in OpenSteer 0.9.</p>
<p>To use an IDE: you will need to expand the contents of the source
code zip
archive, create a new "project" (or whatever it is called on your IDE)
then import OpenSteer's files into the project. You will probably
need to specify where to find header files and where to find the
external libraries OpenGL and GLUT. To install, build
and run on Linux:</p>
<table border="0" cellspacing="3" cellpadding="0" width="90%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox">
      <ol>
        <li><a
 href="http://sourceforge.net/project/showfiles.php?group_id=77546">download</a>
an OpenSteer source release as a zip archive </li>
        <li>expand the zip file to create an <b>opensteer</b>
directory: &nbsp; <span class="nowrap"><b>unzip OpenSteer_0_8_source</b></span>
        </li>
        <li>change to that directory: &nbsp; <span class="nowrap"><b>cd
opensteer</b></span> </li>
        <li>build an executable: &nbsp; <b>make</b> </li>
        <li>launch the application: &nbsp; <b>make run</b> </li>
      </ol>
      </td>
    </tr>
  </tbody>
</table>
<p>Another way to obtain the source code is to "check out" a copy from
<a href="http://sourceforge.net/cvs/?group_id=77546">OpenSteer's CVS
repository at SourceForge</a>. (if you are not a SourceForge member
this can be done ) This allows access to the current
development code, and <a href="http://www.cvshome.org/">CVS</a>
provides other services helpful to developers working on OpenSteer.
It is also possible to <a
 href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/opensteer/">browse
the CVS repository</a> over the web. This is the directory structure
of OpenSteer:</p>
<table border="0" cellspacing="3" cellpadding="0" width="90%"
 align="center">
  <tbody>
    <tr>
      <td class="graybox" width="25%">.../opensteer/</td>
      <td class="graybox">makefile and copyright notice</td>
    </tr>
    <tr>
      <td class="graybox">.../opensteer/src/</td>
      <td class="graybox">source code (*.cpp files)</td>
    </tr>
    <tr>
      <td class="graybox">.../opensteer/include/OpenSteer/</td>
      <td class="graybox">headers (*.h files)</td>
    </tr>
    <tr>
      <td class="graybox">.../opensteer/plugins/</td>
      <td class="graybox">source for supplied SteerTest PlugIns (*.cpp
files)</td>
    </tr>
  </tbody>
</table>
<p>
<big><big><b><br>
<a name="KnownBugs"></a>
Known Bugs and Missing Features
</b></big></big></p>
<ul>
  <li>
    <p>In SteerTest, it seems like you ought to be able to use the
    mouse to interactively adjust position and orientation of the
    vehicles. But you can't. Other things you can't do include
    interactively creating new instances of a PlugIn's vehicle types,
    or deleting old ones. As anyone who has tried it knows, the
    hardest part of creating interesting life-like behaviors is tuning
    the parameters.  It sure would be nice if SteerTest provided
    mouse-driven sliders ("valuators") PlugIns could call to
    interactively adjust behavioral parameters.</p>
  </li>
  <li>
    <p>Some of the behaviors detailed in the <a
 href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">1999
paper</a> have not been implemented yet in OpenSteer. They are:
offset pursuit, arrival, wall following, containment, flow field
following, and leader following. Also unimplemented are behaviors
which the paper mentioned in passing: explore, forage, interpose,
shadow, docking, hide. Eventually OpenSteer should provide all of
them.</p>
  </li>
  <li>
    <p>When avoiding obstacles it looks much more sensible, efficient
    and lifelike if the vehicle steers toward the nearer edge of a
    looming obstacle. But obstacle avoidance is blended with other
    behaviors (say with evasion, as in the Capture the Flag PlugIn)
    this will often steer the vehicle into a strategically bad
    position. Much better to go the "long way" around an obstacle than
    to go directly in to the path of your opponent. Perhaps obstacle
    avoidance should take an argument representing the steering that
    would be used in the absence of an obstacle. This can be used to
    bias the choice of a path around the obstacle. There is an
    underlying suggestion that effective blending of behaviors cannot
    be cleanly separated from the behaviors themselves.</p>
  </li>
  <li>
    <p> Currently the Pedestrians always move forward at full speed
    and try to avoid collisions purely by turning. They should
    be improved so they modulate both their heading <span
    style="font-weight: bold;">and</span> their speed, coming to a
    stop if necessary to avoid a collision.</p>
  </li>
  <li>
    <p>As can be seen occasionally in the Capture the Flag PlugIn,
    when obstacle avoidance steering behavior fails to prevent
    collisions (intersection of vehicle and obstacle) the obstacle
    avoidance behavior appears to give up: it ignores the obstacle and
    steers right through it.</p>
  </li>
  <li>Boids should have a preference for level flight, perhaps as a
  user-selectable option. Right now they are as likely to fly
  straight up and horizontally.<br>
  </li>
  <li>
    <p>One ought to be able to add a PlugIn to SteerTest at runtime.</p>
  </li>
  <li>
    <p>Compiling OpenSteer on GCC requires version 3 or later. (I'm
    not sure if this is a "bug" to be fixed or just a fact to be
    noted.)</p>
  </li>
  <li>
    <p>IDEs (Integrated Development Environments, such as Xcode
    and Visual C++) should be supported in OpenSteer.</p>
  </li>
  <li>
    <p>Non-penetration constraints should be supported in OpenSteer so
    vehicles can be prevented from intersecting obstacles and other
    vehicles.</p>
  </li>
  <li>Current demos use either 2d vehicles on the plane or 3d vehicles
  in space. Opensteer should provide support for 2d vehicles on
  non-planar surfaces.<br>
  </li>
  <li>
    <p>Besides, shouldn't these bugs be listed in the <a
    href="http://sourceforge.net/tracker/?group_id=77546">appropriate
    place</a> on SourceForge?</p>
  </li>
</ul>
<!-- -----------------------------------------------------------------

<big>
<big>
<b>
Miscellaneous Notes:
</b>
</big>
</big>

<p><b>Time</b> is measured in seconds since the simulation was begun,
and represented as a floating point number.  (XXX which begs the
question, should OpenSteer define a "time" type? XXX)</p>

----------------------------------------------------------------- --><big><big>
<b><br>
<a name="RelatedLinks"></a>
Related Links:
</b></big></big><small>&nbsp;&nbsp;
(Please feel free to suggest new links for this section)
</small>
<ul>
  <li>
    <p><a href="index.html">OpenSteer</a> on the web at <a
 href="http://www.sourceforge.net/">SourceForge.Net</a></p>
  </li>
  <li>
    <p><a href="http://www.igda.org/ai/ai_committee.php">AI Interface
    Standards Committee</a> of the <a
    href="http://www.igda.org/">IGDA</a> which includes a Steering
    Working Group</p>
  </li>
  <li>
    <p><a
    href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">Steering
    Behaviors For Autonomous Characters</a> the GDC 1999 paper on
    steering behaviors and this background and update page with <a
    href="http://www.red3d.com/cwr/steer/">Java demos and related
    links</a></p>
  </li>
  <li>Sample applications of steering behaviors:
  <ul>
    <li>
      <p><a
      href="http://www.red3d.com/cwr/papers/2000/pip.html">Interaction
      with Groups of Autonomous Characters</a> (2000) describes a
      interactive system featuring large group of characters based on
      steering behaviors, includes a video.</p>
    </li>
    <li>
      <p><a href=
      "http://www.research.scea.com/oldsite/sig01/sig01_procedural.htm">Video
      Game Play and Design: Procedural Directions</a> (2001) includes
      video of the Stuart/Bird/Fish demo with a skinned articulated 3d
      character driven by steering behaviors.</p>
    </li>
  </ul>
  </li>
</ul>
<br>
<hr>
<br>
<p>Please feel free to <a href="contact.html">contact us</a> with
comments or suggestions.
<br>
<br>
<!-- CHANGE DATE AT TOP OF FILE TOO -->Last update: October 7, 2003 <br>
</p>
<a href="http://sourceforge.net">
<img src="http://sourceforge.net/sflogo.php?group_id=77546&amp;type=1"
 width="88" height="31" border="0" alt="SourceForge.net Logo"></a> <br>
<br>
<a href="index.html">
<img src="images/beta_90a.gif" width="90" height="90" border="0"
 alt="OpenSteer Logo"></a>
</body>
</html>
