<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>OpenSteer Preliminary Documentation</title>
<style type="text/css">
  td.graybox { padding: 2px 8px 2px 8px;
               background-color: #e0e0e0;
               vertical-align: top; }
  span.sourcecode { font-family: monospace; }
  td.boxVM { vertical-align: middle;
             padding: 0 0 0 0;
             color: black;
             background-color: white; }
  body     { color: black;
             background-color: white; }
  .nowrap  { white-space: nowrap; }
</style>
  <!-- I should define a span-level style for code (and one for pathnames,
       "vocabulary" words (like "scare quotes") -->
</head>
<body>

<table border=0 cellspacing=0 cellpadding=0 width="100%">
<tr>
<td class=boxVM align=left>
<small>
May 28, 2003  <!-- CHANGE DATE AT BOTTOM OF FILE TOO -->
<br>
<small>
Version 0.7
</small>
</small>

<br>
<br>

<b>
<big>
<big>
<big>
<big>
<br>
OpenSteer
</big>
</big>
<br>
Documentation
</big>
</big>
</b>
<br>
<br>
<br>
by
<br><a href="http://www.red3d.com/cwr/">Craig Reynolds</a>
<br><a href="http://www.research.scea.com/">Research and Development</a>
<br><a href="http://www.scea.com/">Sony Computer Entertainment America</a>
</td>
<td class=boxVM align=right>
<a href="index.html">
<img src="images/beta_250a.gif"
 width="250" height="250" border="0" alt="OpenSteer Logo"></a>
</td>
</tr>
</table>

<br>
<br>

<!-- rule -->
<table border=0 cellspacing=0 cellpadding=0 width="100%" 
height=2 bgcolor="#f0f0f0"><tr><td></td></tr></table>

<br>

<big>
<big>
<b>
<br>
<a name="TableofContents"></a>
Table of Contents
</b>
</big>
</big>

<br><a href="#Introduction"       >Introduction</a>
<br><a href="#WetPaint"           >Wet Paint</a>
<br><a href="#UsingSteerTest"     >Using SteerTest</a>
<br><a href="#SamplePlugIns"      >Sample PlugIns</a>
<br><a href="#WritingPlugIns"     >Writing PlugIns</a>
<br><a href="#SteeringLibrary"    >Steering Library</a>

<br><a href="#Integrating"        >Integrating with Your Code</a>

<br><a href="#InstallingOpenSteer">Installing OpenSteer</a>
<br><a href="#KnownBugs"          >Known Bugs and Missing Features</a>
<br><a href="#RelatedLinks"       >Related Links</a>
<br>
<br>
<br>

<big>
<big>
<b>
<br>
<a name="Introduction"></a>
Introduction
</b>
</big>
</big>

<p><b>OpenSteer</b> is an open source library of components to help
build <a href="http://www.red3d.com/cwr/steer/">steering behaviors</a>
for autonomous characters in games and other kinds of multi-agent
simulations.  These agents may represent characters (humans, animals,
alien creatures), vehicles (cars, planes, spaceships) or other kinds
of mobile agents.  OpenSteer was developed on Linux and subsequently
ported to Windows and Mac OS X.</p>

<p>OpenSteer provides a toolkit of steering behaviors, defined in
terms of an abstract mobile agent called a <i>vehicle. </i>Sample code
is provided, including a simple vehicle implementation and examples of
combining simple steering behaviors to produce more complex
behavior. In order to allow flexible integration with existing game
engines OpenSteer can add its functionality by either layering or
inheritance.  <small><a href="#Integrating">[see "Integrating with
Your Code" below]</a></small></p>

<p>In addition to the library, OpenSteer provides an OpenGL-based
application called <b>SteerTest</b> which displays predefined
demonstrations of steering behaviors.  The user can quickly prototype,
visualize, annotate and debug new steering behaviors by writing a
plug-in for SteerTest.  SteerTest is written in C++ and uses OpenGL
graphics.  All OpenGL calls are segregated in one module, in case you
need to substitute another graphics API.

<p>SteerTest is based on a <i>PlugIn</i> architecture: an empty
framework into which PlugIns can be added incrementally.  SteerTest
comes with several sample PlugIns.
<small><a href="#SamplePlugIns">[see "Sample PlugIns"
below]</a></small> You can easily create your own PlugIns by starting
from these examples.  A SteerTest PlugIn specifies several generic
actions required by the SteerTest framework: open, close, reset, run
one simulation step, display one frame, and so on.  The PlugIn defines
vehicle classes and manages them in simulation.  It defines scene
geometry in terms of obstacles, pathways and so on.  PlugIns control
the camera and handle Function Keys.</p>

<p>SteerTest's plug-in framework allows a game AI programmer to
quickly prototype behaviors during game design, and to develop
behaviors before the main game engine is finished.  Currently
SteerTest allows the user to interactively stop, start, single step
time, select the vehicle/character/agent of interest, and adjust the
view and tracking behavior of the camera.</p>

<p>OpenSteer is distributed as open source software in accordance with
the <a href="http://www.opensource.org/licenses/mit-license.php">MIT
License</a>.</p>

<big>
<big>
<b>
<br>
<a name="WetPaint"></a>
Wet Paint!
</b>
</big>
</big>

<p>Warning: OpenSteer 0.7 is still under active development.  It is
not mature or stable.  Its current design is subject to change and
reorganization, although every attempt will be made to avoid
gratuitous changes.  We welcome your interest in OpenSteer and
encourage experimentation.  However please 
<a href="contact.html">contact us</a> before planning to integrate
OpenSteer into any large project.</p>

<p>Note also that the term <i>plug-in</i> is currently misused here.
Normally it implies that a new module can be added to an application
at <b>run</b> time.  Whereas in OpenSteer 0.7 the "plugging-in" must
happen at application <b>build</b> (link) time.  One would hope this
was fixed in a future release (he said, hoping to avoid specific
promises of future enhancements).</p>

<big>
<big>
<b>
<br>
<a name="UsingSteerTest"></a>
Using SteerTest
</b>
</big>
</big>

<p>After installation <small><a href="#InstallingOpenSteer">[see
"Installing OpenSteer" below]</a></small> change to the
<b>opensteer</b> directory and run the <b>steertest</b> command.  
When you first use SteerTest, this <a href="stref.html">quick
reference guide</a> may be helpful.  The application will open a
single window labeled "SteerTest", you should see a diagrammatic 3d
view of the default PlugIn.  Typically you will see moving vehicles,
annotation graphics and textual overlays, as shown in <small><a
href="#Figure1">[Figure 1]</a></small>.</p>

<a name="Figure1"></a>
<div align=center>
<img src="images/typical_SteerTest.png"
     width="673" height="558"
     alt="typical SteerTest window">
<br>
<br>
Figure 1: typical SteerTest window
<br>
</div>

<p>In the future SteerTest may have a menu-based graphical user
interface.  For now it supports limited mouse-based interaction
(camera view adjustment, vehicle selection) and recognizes several
single key commands:</p>

<table border=0 cellspacing=3 cellpadding=0 width="90%" align=center>
<tr>
<td class=graybox width="25%">Tab</td>
<td class=graybox>select next PlugIn</td>
</tr>
<tr>
<td class=graybox>r</td>
<td class=graybox>restart current PlugIn</td>
</tr>
<tr>
<td class=graybox>s</td>
<td class=graybox>select next vehicle/agent/character&nbsp; 
                  (or mouse-click to select)</td>
</tr>
<tr>
<td class=graybox>c</td>
<td class=graybox>select next camera aiming mode</td>
</tr>
<tr>
<td class=graybox>f</td>
<td class=graybox>select next preset frame rate&nbsp;
                  (as-fast-as-possible, 24fps, 60fps)</td>
</tr>
<tr>
<td class=graybox>Space</td>
<td class=graybox>toggle between Run and Pause</td>
</tr>
<tr>
<td class=graybox>-> &nbsp; (right arrow)</td>
<td class=graybox>step forward one frame</td>
</tr>
<tr>
<td class=graybox>?</td>
<td class=graybox>print "mini help" on console&nbsp; (or see the
                  <a href="stref.html">quick reference guide</a>)</td>
</tr>
<tr>
<td class=graybox>Esc</td>
<td class=graybox>exit SteerTest</td>
</tr>
</table>

<p>SteerTest keeps track of a single <i>selected</i> agent which the
camera follows.  In some demos additional annotation is provided for
the selected agent.  The user can change selection with the mouse.
Pointing the mouse near an agent will cause it to highlight (for
example, in the provided 2d demos, a gray disk is drawn under it).
Clicking the (left) mouse button selects the highlighted agent.
SteerTest's camera (<i>point of view</i>) adjusts itself automatically
to keep the selected vehicle in view.  Several different camera aiming
modes are provided:</p>

<table border=0 cellspacing=3 cellpadding=0 width="90%" align=center>
<tr>
<td class=graybox width="25%">static</td>
<td class=graybox>fixed camera</td>
</tr>
<tr>
<td class=graybox>fixed&nbsp;distance&nbsp;offset</td>
<td class=graybox>
camera remains a fixed distance from selected vehicle
</td>
</tr>
<tr>
<td class=graybox>fixed local offset</td>
<td class=graybox>
camera remains fixed in selected vehicle's local space
</td>
</tr>
<tr>
<td class=graybox>straight down</td>
<td class=graybox>
camera looks at selected vehicle from directly above
</td>
</tr>
<tr>
<td class=graybox>offset POV</td>
<td class=graybox>
camera looks in selected vehicle's forward direction, from a given
offset in the vehicle's local space
</td>
</tr>
</table>


<p>You can adjust the camera's view with the mouse (or whatever input
device you use).  SteerTest lets you adjust the camera's <i>position
</i>relative to its <i>aimpoint. </i>The aimpoint is defined by camera
aiming mode and is normally the (predicted future position of the)
selected vehicle.  To adjust the camera: hold down the keyboard's
<i>control </i>(Ctrl) key while dragging the mouse with its left
button held down.  2D mouse motion is mapped into the camera's space,
rotating the camera's position around its aimpoint.  This allows the
camera to move on the surface of a sphere centered at the aimpoint.
The radius of this sphere--the "viewing distance"--can be adjusted by
dragging the mouse with the middle button held down (vertical mouse
motion maps to distance).  If you use a one- or two-button mouse
(hence no middle button) you can adjust the radius by holding down
both the Ctrl and Alt ("control-meta-") keys while dragging the mouse
with its left button held down.  Note that adjustments in "offset POV"
camera aiming mode actually translate rather than rotate the camera
position relative to the selected vehicle.</p>

<p>To preserve a stable view, SteerTest's camera will smoothly
interpolate over changes due to: motion of the selected vehicle,
mouse-based camera adjustment, or switching camera aiming modes.</p>

<p>SteerTest's clock provides two time streams: <i>real time </i>and
<i>simulation time. </i>The redraw cycle and camera update are based
on passage of real time.  Simulation time normally follows real time
but can also be <i>paused, </i>freezing simulation of vehicle motion.
Pausing the simulation often helps to allow examining annotation in
detail, or to interactively reposition the camera.  (In the current
implementation: when simulation time is paused, simulation updates
continue to happen each frame, but the <i>elapsed time </i>("dt") is
given as zero.)  The clock can be set to run in a variable frame rate
"as fast as possible" mode or to run at a given fixed frame rate.  In
the latter, the system will wait after a simulate-redraw for the start
of a new frame boundary.  If the update takes longer than a frame time
it waits for the second frame boundary (aka "frame out" or "double
framing").  You can control this behavior with SteerTest's
<b>&nbsp;f&nbsp;</b> keyboard command (to cycle among frame rate
presets) or from your PlugIn code by setting<span class=sourcecode>
SteerTest::clock.targetFPS </span>(an int) to the desired frame rate,
or 0 for variable frame rate.  For more detail, see <b>Clock.h</b></p>

<p>SteerTest aims to support a developer's work by providing tools and
utilities that while helpful, might not be critical enough to justify
writing them during a production schedule.  This includes various API
for drawing annotation using elements such as lines, vectors, boxes,
circles, disks, spheres and text attached to the screen or positions
in 3d space.  A facility is provided for drawing <i>streamers/trails
</i>which display a vehicle's recent motion then fade away.  There are
utilities for drawing a ground plane and highlighting vehicles in
various ways.  See <b>Annotation.h</b> and <b>SteerTest.h</b> for
details.</p>

<p>
<big>
<big>
<b>
<br>
<a name="SamplePlugIns"></a>
Sample PlugIns
</b>
</big>
</big>
</p>

SteerTest is distributed with several PlugIns intended to serve both
as demonstrations of steering behaviors, and as sample code: jumping
off places for you to begin developing your own steering behaviors.
The current list of sample PlugIns are:

<p><b>Capture the Flag:</b> a single (bluish) attacker attempts to
reach a central goal while four (reddish) defenders try to intercept
("tag") the attacker before it gets to the goal.  The playing field is
optionally littered with obstacles.  This benchmark was proposed by
Marcin Chady of the Working Group on Steering of the IGDA's AI
Interface Standards Committee.  The obstacles are spheres, depicted by
their equator.  Press F1 to add an obstacle (up to 100 of them), F2 to
remove one.  The "game" ends when the attacker reaches the goal or a
defender tags the attacker.  The demo automatically restarts a few
seconds later.  The attacker combines three basic steering behaviors:
<i>goal seeking,</i> <i>evasion</i> and <i>obstacle avoidance</i>.
The defenders combine <i>pursuit</i> and <i>obstacle avoidance.</i> A
key to "non-stupid" behavior by the attacker was to notice when there
is a defender-free "corridor" between it and the goal.  When found,
this corridor is depicted by a green outline.  In this case the
attacker uses pure <i>seek</i> and stops evading nearby defenders.
The pursuit behavior of the defenders needed to specialized so that
they "knew" not to predict the motion of the attacker past its goal.
The defenders do not otherwise think about global strategy, for
example they don't try to place themselves between the attacker and
the goal.  Currently defenders ignore each other, they probably should
separate or avoid collisions with each other, ideally they would
coordinate their pursuit.  The attacker is easily confused when
several defenders converge from different directions.  Obstacles are
always avoided by going toward the nearer edge, as discussed in the
Steering Working Group's forum, this is frequently the "wrong"
direction when considering the agent's other goals.  I want to revisit
this later.</p>

<p><b>Pedestrians:</b> 70 agents follow a path (the red line) while
avoiding collisions with each other and two large spherical obstacles.
They also wander as they move.  Press F1 to toggle the wander
component on and off.  This was a pre-OpenSteer behavioral model I
ported into SteerTest.  (The port was painless but since I wrote both
systems that is not a very strong testimonial to the usability of the
Library.)  Currently the pedestrians avoid collisions only by turning,
eventually they should also modulate their speed.</p>

<p><b>Boids:</b> 100 simulated flocking "bird like objects".  The
boids model is a simple combination of <i>separation, alignment
</i>and <i>cohesion </i>steering behaviors.  When a boid travels
outside of a large spherical enclosure, it will also <i>seek</i>
towards the center.</p>

<p><b>Multiple Pursuit:</b> a "test fixture" for the <i>pursue</i>
behavior.  30 pursuers chase one wandering quarry.  The colored lines
indicate the predicted future position of the quarry being used as a
<i>seek</i> target by each pursuer.  The colors indicate which of nine
prediction cases is active. When a pursuer reaches the quarry it is
"teleported" away to a random position.</p>

<p><b>Low Speed Turn:</b> a "test fixture" for evaluating the response
of a vehicle to backward-pointing steering force while moving at low
speed.</p>

<p><b>One Turning Away:</b> this is the first one, I'm just keeping it
for old time sake right now.</p>

<p>
<big>
<big>
<b>
<br>
<a name="WritingPlugIns"></a>
Writing PlugIns
</b>
</big>
</big>
</p>

<p><i>Note: this section is preliminary, incomplete and subject
to change.</i></p>

<p>Developing interesting, lifelike steering behaviors is an unique
type of programming.  It mixes the mathematical and algorithmic rigor
of computer programming with a more artistic, aesthetic-based phase of
parameter tweaking.  OpenSteer is intended to allow you to focus on
developing steering behaviors without having to worry about all of the
required framework.  This is supported through SteerTest's PlugIn
mechanism.  When you write a PlugIn, you need to provide only the code
that is specific to your own steering behaviors and vehicles.</p>

<p>Currently the best source of detailed information on the PlugIn
interface is in the C++ header file <b>PlugIn.h</b>.  See particularly
the commented-out meta-example called<span class=sourcecode>
FooPlugIn. </span>That header file defines two classes:<span
class=sourcecode> AbstractPlugIn </span>(a pure virtual interface
class) and<span class=sourcecode> PlugIn </span>which provides the
base implementation.  To create a new SteerTest PlugIn, you will
define a new class which inherits the base implementation from<span
class=sourcecode> PlugIn. </span>It provides some default methods (see
<b>PlugIn.h</b> for details) which you can overload to customize,
particularly<span class=sourcecode> reset</span>. You must implement
six methods on your new class to fulfill the<span class=sourcecode>
AbstractPlugIn </span>protocol:</p>

<table border=0 cellspacing=3 cellpadding=0 width="90%" align=center>
<tr>
<td class=graybox width="25%"><span class=sourcecode>name</span></td>
<td class=graybox>returns a character string name</td>
</tr>
<tr>
<td class=graybox><span class=sourcecode>open</span></td>
<td class=graybox>allocate and initialize vehicles</td>
</tr>
<tr>
<td class=graybox><span class=sourcecode>close</span></td>
<td class=graybox>deallocate</td>
</tr>
<tr>
<td class=graybox><span class=sourcecode>update</span></td>
<td class=graybox>perform one stimulation step</td>
</tr>
<tr>
<td class=graybox><span class=sourcecode>redraw</span></td>
<td class=graybox>do all graphics for one frame</td>
</tr>
<tr>
<td class=graybox><span class=sourcecode>allVehicles</span></td> 
<td class=graybox>return a group of all this PlugIn's vehicles</td>
</tr>
</table>

<p>For a minimal working PlugIn see "One Turning Away"
(<b>opensteer/plugins/OneTurning.cpp</b>) which defines a single
vehicle with trivial behavior.  LowSpeedTurn also has trivial behavior
and features multiple vehicles, Boids has many vehicles,
MultiplePursuit has two kinds of vehicles, Pedestrian and
CaptureTheFlag are more complicated samples.</p>

<p>Probably the easiest way to get started on your own PlugIn is to
pick one of the samples that seems most closely related, make a
renamed copy of it, build OpenSteer to verify that the new PlugIn
appears in SteerTest and has its old behavior, then make incremental
changes to the working PlugIn.  (Note: <b>in OpenSteer 0.7: </b>you
should leave your new PlugIn's source file in the same directory as
the provided sample PlugIns (<b>opensteer/plugins/</b>).  That way it
will be automatically compiled and linked when OpenSteer is built,
without requiring any changes to the Makefile.)</p>

<p>The samples in <b>opensteer/plugins/</b> each define at least one
new vehicle class and one new PlugIn class.  A key requirement is that
a single instance of the new PlugIn class be statically allocated, as
in:</p>

<blockquote>
<span class=sourcecode>
// define a new Vehicle<br>
class OneTurning : public SimpleVehicle {...}<br>
<br>
// define a new PlugIn<br>
class OneTurningPlugIn : public PlugIn {...}<br>
<br>
// instantiate the PlugIn<br>
<b>OneTurningPlugIn gOneTurningPlugIn;</b>
</span>
</blockquote>

<p>The name of that global 
(<span class=sourcecode>gOneTurningPlugIn</span>) is irrelevant, what
matters is that a single instance of the new PlugIn class 
(<span class=sourcecode>OneTurningPlugIn</span>) is allocated for the
lifetime of the SteerTest application.  The actual "plugging in" is
handled by the constructor(/destructor) of the<span class=sourcecode>
PlugIn</span> base class.  A class which is intended to be
instantiated exactly once is sometimes called a <i>singleton</i>.
PlugIns expect to be instantiated exactly once but do not enforce or
detect violations of that policy.  Because PlugIns register
themselves, the samples are defined in <b>.cpp</b> files and there is
no need for <b>.h</b> files.  You may wish to organize your PlugIn
differently, perhaps with a <b>.h</b> file or perhaps including one
for a class of vehicle defined elsewhere.</p>

<p>Normally your PlugIn will define one or more classes of Vehicle.
OpenSteer tries to provide a lot of flexibility in how this can be
done.  On the other hand, if you are just trying to get your first
experiment running under SteerTest, you probably want what Devo called
"freedom <i>from </i>choice."  The easiest approach, and what all the
provided samples do, is to define a new vehicle class as a
specialization of<span class=sourcecode> SimpleVehicle.  </span>In
general, all that is required to make use of the OpenSteer steering
library is to support the<span class=sourcecode>
AbstractVehicle</span> protocol in whatever manner you see fit.</p>

<p>SteerTest and the provided PlugIns make use of two types defined
in<span class=sourcecode> AbstractVehicle: AbstractVehicle::group
</span>and<span class=sourcecode> AbstractVehicle::iterator</span>.
These are<span class=sourcecode> typedef</span>ed to the names<span
class=sourcecode> AVGroup </span>and<span class=sourcecode>
AVIterator. AVGroup</span> is used whenever a group of<span
class=sourcecode> AbstractVehicle</span>s need to be remembered or
passed as a function argument.<span class=sourcecode>
AVIterator </span>is used to iterate over the contents of an<span
class=sourcecode> AVGroup. </span>These types are based on the C++ STL
(Standard Template Library) parameterized types<span class=sourcecode>
vector </span>and<span class=sourcecode> const_iterator. AVGroup
</span>and<span class=sourcecode> AVIterator </span>are used inside
the OpenSteer library, but if you wish to avoid using STL it should be
easy to replace them with your own implementation of collections and
iteration.</p>

<p>Random notes for PlugIn writers:
<ul>

<li><p>Time values are currently passed as float values, measured in
seconds.  Perhaps there should be a more specific typedef for time.</p>

<li><p><span class=sourcecode>Vec3 </span>is the type used throughout
OpenSteer to represent geometric vectors in 3D Cartesian space.
Colors are currently represented as
<span class=sourcecode>Vec3</span>s.  Perhaps there should be a more
specific typedef for color.</p>

<li><p>SteerTest expects a PlugIn's<span class=sourcecode> open
</span>method to set<span class=sourcecode> SteerTest::selectedVehicle
</span>to point to one of the PlugIn's vehicles.  SteerTest will print
a warning if it is not set.</p>

<li><p>To annotate, print something or otherwise process just one of
the many vehicles in your PlugIn, use can use something like this in
an update method:&nbsp;&nbsp;
<span class=sourcecode>
if&nbsp;(this&nbsp;==&nbsp;SteerTest::selectedVehicle)&nbsp;{...}</span>
</p>
</ul>


<p>
<big>
<big>
<b>
<br>
<a name="SteeringLibrary"></a>
Steering Library
</b>
</big>
</big>
</p>


<p><i>Note: this section is preliminary and subject to change.  The
documentation could conceivably be out of sync with the library itself.
For the Real Truth always consult the source code.</i></p>

<p>In current organization of OpenSteer, its main library of steering
behaviors is contained in the class SteerLibraryMixin (defined in
<b>SteerLibrary.h</b>).  A mixin is a class with templated superclass
-- it is used to add a set of methods to a given base class.
<small><a href="#Integrating">[see "Integrating with Your Code"
below]</a></small>  In this case SteerLibraryMixin adds steering
functionality to a class which supports the AbstractVehicle interface.
For example, SimpleVehicle combines SteerLibraryMixin and several
other utilities with AbstractVehicle.  As a result, SimpleVehicle has
all of the methods defined in SteerLibraryMixin, which are listed
below.</p>

<p>Note that several of the steering behaviors will signal a zero
vector value (0, 0, 0) to indicate "no steering is required at this
time."  These cases can be detected by the caller by testing to see if
the returned steering value is equal to zero: <span class=sourcecode>
&nbsp;if&nbsp;(steering&nbsp;==&nbsp;Vec3::zero)&nbsp;...</span></p>


<b>Wander behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForWander (float dt);
</pre>
<p>Returns a steering force for wandering behavior.  The steering
value is purely tangential (has no Forward component).  The time step
value allows wander rate to be consistent when frame times vary.</p>
</blockquote>

<b>Seek behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForSeek (const Vec3&amp; target);
</pre>
<p>Returns a steering force to seek the given target location.  Causes
a vehicle to turn toward the target and move to it.  If this behavior
is used alone and unconditionally, it will cause the vehicle to pass
through the target then turn around for another pass.</p>
</blockquote>

<b>Flee behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForFlee (const Vec3&amp; target);
</pre>
<p>Returns a steering force to flee from the given target location.
Causes a vehicle to turn away from the target and move away from it
it.</p>
</blockquote>

<b>Path Following behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForPathFollowing (const float predictionTime, Pathway&amp; path);
</pre>
<p>Returns a steering force to follow the given path.  The path
defines a <i>tube </i>in terms of a <i>spine </i>and a <i>radius </i>,
the goal is to keep a vehicle headed toward a point inside that tube.
Steering is determined based on a prediction of the vehicle's
position<span class=sourcecode> predictionTime </span>seconds into the
future.  If that predicted position is inside the pathway, this
function returns a zero vector value.</p>
</blockquote>

<b>Obstacle Avoidance behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerToAvoidObstacle (const Obstacle&amp; obstacle,
                           const float minTimeToCollision);
</pre>
<p>Returns a steering force to avoid a given obstacle.  The purely
lateral steering force will turn our vehicle towards a silhouette edge
of the obstacle.  Avoidance is required when (1) the obstacle
intersects the vehicle's current path, and (2) it is in front of the
vehicle, and (3) is within<span class=sourcecode> minTimeToCollision
</span>seconds of travel at the vehicle's current velocity.  When no
avoidance is required this function returns a zero vector value.</p>
</blockquote>

<b>Unaligned Collision Avoidance behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerToAvoidNeighbors (const float minTimeToCollision,
                            const AVGroup&amp; others);
</pre>
<p>Returns a steering force to avoid colliding with other nearby
vehicles moving in unconstrained directions.  Determine which (if any)
other other vehicle we would collide with first, then steers to avoid
the site of that potential collision.  <i>(The current version only
steers laterally, it does not speed up or slow down, as described in
the <a href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">GDC
1999 paper</a>.) </i>Returns a steering force vector of zero length if
there is no impending collision.</p>
</blockquote>

<b>Separation behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForSeparation (const float maxDistance,
                         const float cosMaxAngle,
                         const AVGroup&amp; flock);
</pre>
<p>Returns a steering force to move us away from nearby boids.</p>
</blockquote>

<b>Alignment behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForAlignment (const float maxDistance,
                        const float cosMaxAngle,
                        const AVGroup&amp; flock);
</pre>
<p>Returns a steering force to align us with nearby boids.</p>
</blockquote>

<b>Cohesion behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForCohesion (const float maxDistance,
                       const float cosMaxAngle,
                       const AVGroup&amp; flock);
</pre>
<p>Returns a steering force to move us towards the "center of mass" of
nearby boids.</p>
</blockquote>

<b>Pursuit behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForPursuit (const AbstractVehicle&amp; quarry);

Vec3 steerForPursuit (const AbstractVehicle&amp; quarry,
                      const float maxPredictionTime);
</pre>
<p>Returns a steering force to pursue another moving vehicle.  Heads
towards the predicted point of interception.  An alternate version is
provided to specify a ceiling on the prediction interval: aim for
where the quarry will be in (say) 5 seconds, or the point of
interception, whichever happens sooner.</p>
</blockquote>

<b>Evasion behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForEvasion (const AbstractVehicle&amp; menace,
                      const float maxPredictionTime);
</pre>
<p>Returns a steering force to evade another moving vehicle.  Heads
away from the predicted point of interception.</p>
</blockquote>

<b>Speed Maintenance behavior</b>
<br>
<blockquote>
<pre>
Vec3 steerForTargetSpeed (const float targetSpeed);
</pre>
<p>Returns a steering force to maintain a given target speed.  The
value will be along the vehicle's forward/backward axis and its length
will be clipped to the vehicle's maxForce parameter.</p>
</blockquote>


<p>
<big>
<big>
<b>
<br>
<a name="Integrating"></a>
Integrating with Your Code
</b>
</big>
</big>
</p>


<p><i>Note: this section is so preliminary that it is really just a
placeholder...</i></p>

<p>This section will eventually talk about the structure of
OpenSteer's classes, and how they are designed to provide you with
flexibility as you integrate OpenSteer with your existing code.  It
will mention that if you were writing news code, you could always base
your classes on OpenSteer's.  More typically you will already have an
existing code base, a game engine or a procedural animation system,
into which you want to integrate some of OpenSteer's facilities.</p>

<p>OpenSteer's classes have been designed to allow you freedom to
either inherit its functionality, or to layer its functionality on top
of your existing classes.  The latter approach is supported by the
concept of 

<a href="http://citeseer.nj.nec.com/smaragdakis00mixinbased.html">
mixin classes</a> (essentially a class with templated superclass)
which allows its functionality to be "mixed in with" (or "layered on
top of") your existing classes.  A similar effect can be obtained by
multiple inheritance of your preexisting base classes and OpenSteer's
classes, but most C++ programmers prefer to avoid multiple
inheritance.  Many of OpenSteer's classes are defined in three parts:
an abstract protocol (aka interface or pure virtual class:
"AbstractLocalSpace"), an implementation expressed as a mixin
("LocalSpaceMixin") and an instantiable class made by layering the
mixin on top of the abstract protocol ("LocalSpace").  For more detail
see <b>LocalSpace.h</b> and the discussion at the top of
<b>SimpleVehicle.h</b></p>

<p>Finally OpenSteer anticipates that it may be used in class
hierarchies based on either the IS-A or the HAS-A architecture.  That
is, you might want an agent in your game to be structured so that it
IS-A OpenSteer Vehicle or you may want to structure it so that it HAS-A
Vehicle as a component part.</p>


<p>
<big>
<big>
<b>
<br>
<a name="InstallingOpenSteer"></a>
Installing OpenSteer
</b>
</big>
</big>
</p>


<p><i>Note: this section is preliminary and subject to change.
OpenSteer uses two external libraries: OpenGL and GLUT, you may need
to install them before you can build OpenSteer.</i></p>

<p>You can download software at

<a href="http://sourceforge.net/project/showfiles.php?group_id=77546">
OpenSteer's file release page at SourceForge</a>.  OpenSteer 0.7 is
released in source form only, as a zip archive called
<b>OpenSteer_0_7_source.zip</b>.  In the future we hope to provide
precompiled binary releases.  OpenSteer 0.7 includes a Makefile to
build the system under Linux and related systems. In the future we
hope to provide support for popular IDEs (Integrated Development
Environments) such as ProjectBuilder and Visual C++.</p>

<p>To use an IDE: you will need to expand the contents of the zip
archive, create a new "project" (or whatever it is called on your IDE)
then import OpenSteer's files into the project.  You will probably
need to specify where to find header files and where to find the
external libraries OpenGL and GLUT.  OpenSteer 0.7 have been
successfully built on Windows using Visual C++ (versions 6 and 7 (with
warnings)) and on Mac OS X using ProjectBuilder.  To install, build
and run under Linux:</p>

<table border=0 cellspacing=3 cellpadding=0 width="90%" align=center>
<tr>
<td class=graybox>
<ol>
<li><a href="http://sourceforge.net/project/showfiles.php?group_id=77546">
    download</a> an OpenSteer source release as a zip archive
<li>expand the zip file to create an <b>opensteer</b> directory: &nbsp;
    <span class=nowrap><b>unzip OpenSteer_0_7_source</b></span>
<li>change to that directory: &nbsp;
    <span class=nowrap><b>cd opensteer</b></span>
<li>build an executable: &nbsp; <b>make</b>
<li>launch the application: &nbsp; <b>steertest</b> &nbsp;
    (you might need to say <b>./steertest</b>)
</ol>
</td>
</tr>
</table>


<p>Another way to obtain the source code is to "checkout" a copy from
<a href="http://sourceforge.net/cvs/?group_id=77546">OpenSteer's CVS
repository at SourceForge</a>.  This allows access to the current
development code, and <a href="http://www.cvshome.org/">CVS</a>
provides other services helpful to developers working on OpenSteer.
It is also possible to <a
href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/opensteer/">browse
the CVS repository</a> over the web.  This is the directory structure
of OpenSteer:</p>


<table border=0 cellspacing=3 cellpadding=0 width="90%" align=center>
<tr>
<td class=graybox width="25%">.../opensteer/</td>
<td class=graybox>makefile and copyright notice</td>
</tr>
<tr>
<td class=graybox>.../opensteer/src/</td>
<td class=graybox>source code (*.cpp files)</td>
</tr>
<tr>
<td class=graybox>.../opensteer/include/OpenSteer/</td>
<td class=graybox>headers (*.h files)</td>
</tr>
<tr>
<td class=graybox>.../opensteer/plugins/</td>
<td class=graybox>source for supplied SteerTest PlugIns</td>
</tr>
</table>


<p>
<big>
<big>
<b>
<br>
<a name="KnownBugs"></a>
Known Bugs and Missing Features
</b>
</big>
</big>
</p>

<ul>

<li><p>In SteerTest, it seems like you ought to be able to use the
mouse to interactively adjust position and orientation of the
vehicles.  But you can't.  Other things you cannot do include
interactively creating new instances of a PlugIn's vehicle types, or
deleting old ones.  As anyone who has tried it knows, the hardest part
of creating interesting life-like behaviors is tuning the parameters.
It sure would be nice if SteerTest provided mouse-driven sliders
("valuators") PlugIns could call to interactively adjust behavioral
parameters.</p>

<li><p>OpenSteer does not yet have a facility to accelerate
<i>locality queries.  </i>Many group behaviors, such as the Boids and
Pedestrian samples, are based on local interaction.  Each individual
must first determine which other group members are within their local
neighborhood.  The naive approach has asymptotic complexity
0(n<sup><small><small>2</small></small></sup>) which quickly becomes
prohibitive for large groups.  OpenSteer needs a spatial database such
as the one used in the section "Locality Queries" in 
<a href="http://www.red3d.com/cwr/papers/2000/pip.html">Interaction
with Groups of Autonomous Characters</a>.  It has been designed but
not implemented.</p>

<li><p>Some of the behaviors detailed in the
<a href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">1999
paper</a> have not been implemented yet in OpenSteer.  They are:
offset pursuit, arrival, wall following, containment, flow field
following, and leader following.  Also unimplemented are behaviors
which the paper mentioned in passing: explore, forage, interpose,
shadow, docking, hide.  Ideally OpenSteer should provide all of
them.</p>

<li><p>When avoiding obstacles it looks much more sensible, efficient
and lifelike if the vehicle steers toward the nearer edge of a looming
obstacle.  But obstacle avoidance is blended with other behaviors (say
with evasion, as in the Capture the Flag PlugIn) this will often steer
the vehicle into a strategically bad position.  Much better to go the
"long way" around an obstacle than to go directly in to the path of
your opponent.  Perhaps obstacle avoidance should take an argument
representing the steering that would be used in the absence of an
obstacle.  This can be used to bias the choice of a path around the
obstacle.  There is an underlying suggestion that effective blending
of behaviors cannot be cleanly separated from the behaviors
themselves.</p>

<li><p>One ought to be able to add a PlugIn to SteerTest at runtime.</p>

<li><p>In the Boid demo, there is no constraint on roll.  The boids
end up at an arbitrary rotation about their forward axis.  They should
keep their UP up and bank around turns.  They should have a preference
for level flight.</p>

<li><p>In the Pedestrian demo, there is a problem at one end (inside
the loop) of the path: path following gets briefly confused.</p>

<li><p>Compiling OpenSteer on GCC requires version 3 or later.  (I'm
not sure if this is a "bug" to be fixed or just a fact to be noted.)</p>

<!-- <li><p>Sources and sinks.</p> -->

<li><p>And so on...  Which is why I'm estimating this glass is 0.7
full.</p>

</ul>


<!-- -----------------------------------------------------------------

<big>
<big>
<b>
Miscellaneous Notes:
</b>
</big>
</big>

<p><b>Time</b> is measured in seconds since the simulation was begun,
and represented as a floating point number.  (XXX which begs the
question, should OpenSteer define a "time" type? XXX)</p>

----------------------------------------------------------------- -->

<big>
<big>
<b>
<br>
<a name="RelatedLinks"></a>
Related Links:
</b>
</big>
</big>

<small>
&nbsp;&nbsp;
(Please feel free to suggest new links for this section)
</small>

<ul>

<li><p><a href="index.html">OpenSteer</a> on the web at
<a href="http://www.sourceforge.net/">SourceForge.Net</a></p>

<li><p><a href="http://www.red3d.com/cwr/papers/1999/gdc99steer.html">
Steering Behaviors For Autonomous Characters</a> the GDC 1999 paper on
steering behaviors and this background and update page with <a
href="http://www.red3d.com/cwr/steer/">Java demos and related
links</a></p>

<li><p><a href="http://www.igda.org/ai/ai_committee.php">AI Interface
Standards Committee</a> of the <a href="http://www.igda.org/">IGDA</a>
which includes a Steering Working Group</p>

<p><a href=""></a></p>

</ul>

<br>
<hr>
<br>

<p>Please feel free to <a href="contact.html">contact us</a> with
comments or suggestions.
<br>
<br>
Last update: May 28, 2003  <!-- CHANGE DATE AT TOP OF FILE TOO -->
<br>
</p>

<a href="http://sourceforge.net">
<IMG src="http://sourceforge.net/sflogo.php?group_id=77546&amp;type=1"
 width="88" height="31" border="0" alt="SourceForge.net Logo"></a> 

<br>
<br>

<a href="index.html">
<img src="images/beta_90a.gif"
 width="90" height="90" border="0" alt="OpenSteer Logo"></a>

</body>
</html>
